#+STARTUP: inlineimages
#+ATTR_ORG: :width 800px

* Anoop index:
How Do I Get Started?
Applied Machine Learning Process
Linear Algebra
Statistical Methods
Understand Machine Learning Algorithms
Python Machine Learning (scikit-learn)
Code Algorithm from Scratch (Python)
Introduction to Time Series Forecasting (Python)
XGBoost in Python (Stochastic Gradient Boosting)
Deep Learning (Keras)
Long Short-Term Memory (LSTM)
Deep Learning for Natural Language Processing (NLP)
Deep Learning for Time Series Forecasting


* experimental0
chrome history suggestions based on a neural network
read to get ideas for projects: https://machinelearningmastery.com/self-study-machine-learning-projects/
maintain a ml daily blog?
how to get computers to talk to each other using socket programming
use free time with phone to study google maps of Bangalore like guttapalli
buy toothbrush, bigger bulb for room
sabji kitne ki hai app

* How Do I Get Started?

** articles-read, worth rereading
 $$ Applied Machine Learning Process
 $$ Intermediate: Python Ecosystem.

$$ Step 4: Practice on Datasets. Select datasets to work on and practice the process. 

 $$ Practice Machine Learning with Small In-Memory Datasets
 $$ Tour of Real-World Machine Learning Problems
 $$ Work on Machine Learning Problems That Matter To You

$$ Step 5: Build a Portfolio. Gather results and demonstrate your skills. 

 $$ Build a Machine Learning Portfolio
 $$ Get Paid To Apply Machine Learning
 $$ Machine Learning For Money

For more on this top-down approach, see:

$$ The Machine Learning Mastery Method
$$ Machine Learning for Programmers

Many of my students have used this approach to go on and do well in Kaggle competitions and get jobs as Machine Learning Engineers and Data Scientists.

** notes

*** intro
sckit-learn is higher level than numpy & scipy
machine learning is a subset of artificial intelligence
artificial learning is a more consistent name for machine learning

*** some key word definitions:
Model: A machine learning model can be a mathematical representation
of a real-world process. To generate a machine learning model you will
need to provide training data to a machine learning algorithm to learn
from.

Algorithm: Machine Learning algorithm is the hypothesis set that is
taken at the beginning before the training starts with real-world
data. When we say Linear Regression algorithm, it means a set of
functions that define similar characteristics as defined by Linear
Regression and from those set of functions we will choose one function
that fits the most by the training data.

Training: While training for machine learning, you pass an algorithm
with training data. The learning algorithm finds patterns in the
training data such that the input parameters correspond to the target.
The output of the training process is a machine learning model which
you can then use to make predictions. This process is also called
“learning”.

Regression: Regression techniques are used when the output is
real-valued based on continuous variables. For example, any time
series data. This technique involves fitting a line.

Classification: In classification, you will need to categorize data
into predefined classes. For example, an email can either be ‘spam’ or
‘not spam’.

Target: The target is whatever the output of the input variables. It
could be the individual classes that the input variables maybe mapped
to in case of a classification problem or the output value range in a
regression problem. If the training set is considered then the target
is the training output values that will be considered.

Feature: Features are individual independent variables that act as the
input in your system. Prediction models use features to make
predictions. New features can also be obtained from old features using
a method known as ‘feature engineering’. More simply, you can consider
one column of your data set to be one feature. Sometimes these are
also called attributes. And the number of features are called
dimensions.

Label: Labels are the final output. You can also consider the output
classes to be the labels. When data scientists speak of labeled data,
they mean groups of samples that have been tagged to one or more
labels.

Overfitting: An important consideration in machine learning is how
well the approximation of the target function that has been trained
using training data, generalizes to new data. Generalization works
best if the signal or the sample that is used as the training data has
a high signal to noise ratio. If that is not the case, generalization
would be poor and we will not get good predictions. A model is
overfitting if it fits the training data too well and there is a poor
generalization of new data.

Regularization: Regularization is the method to estimate a preferred
complexity of the machine learning model so that the model generalizes
and the over-fit/under-fit problem is avoided. This is done by adding
a penalty on the different parameters of the model thereby reducing
the freedom of the model.

Parameter and Hyper-Parameter: Parameters are configuration variables
that can be thought to be internal to the model as they can be
estimated from the training data. Algorithms have mechanisms to
optimize parameters. On the other hand, hyperparameters cannot be
estimated from the training data. Hyperparameters of a model are set
and tuned depending on a combination of some heuristics and the
experience and domain knowledge of the data scientist.


* https://machinelearningmastery.com/python-machine-learning-mini-course/
14Lessons
** pre requisite https://machinelearningmastery.com/gentle-introduction-to-the-bias-variance-trade-off-in-machine-learning/
*Bias Error*
Bias are the simplifying assumptions made by a model to make the target function easier to learn.
Low Bias: Suggests less assumptions about the form of the target function.
High-Bias: Suggests more assumptions about the form of the target function.

Examples of low-bias machine learning algorithms include: Decision Trees, k-Nearest Neighbors and Support Vector Machines.
Examples of high-bias machine learning algorithms include: Linear Regression, Linear Discriminant Analysis and Logistic Regression.

*Variance Error*
Variance is the amount that the estimate of the target function will change if different training data was used.

Examples of low-variance machine learning algorithms include: Linear Regression, Linear Discriminant Analysis and Logistic Regression.
Examples of high-variance machine learning algorithms include: Decision Trees, k-Nearest Neighbors and Support Vector Machines.

Fig 1. bulls-eye visualise http://scott.fortmann-roe.com/docs/BiasVariance.html

skill of the model, a score with 
a high variance = (that may change a lot based on the data used to fit the model), or 
a high bias = (such as an overestimate of the skill of the model).

** 1 - install
*** next time try using this tutorial https://sourabhbajaj.com/mac-setup/Python/numpy.html
*** make a new virtualenv
#+BEGIN_SRC shell
pwd
#+END_SRC

#+RESULTS:
: /Users/anoop/ml/flipshope


Use :session: property to speed up org-babel when possible to use the same session
#+BEGIN_SRC bash :session session007 :results output
    source ~/.bashrc
    #mkvirtualenv mlm
    workon mlm
    which python
    #+END_SRC

#+RESULTS:
: /Users/anoop/ml/flipshope ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
: :/Users/anoop/ml/flipshope ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
: :(mlm) /Users/anoop/ml/flipshope ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
: :/Users/anoop/.virtualenvs/mlm/bin/python
: (mlm) /Users/anoop/ml/flipshope ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#+BEGIN_SRC elisp :session session007 :results output
  (pyvenv-workon "mlm2")
#+END_SRC

#+RESULTS:

*** install https://stackoverflow.com/questions/26319762/how-to-install-scipy-stack-with-pip-and-homebrew
pip install numpy
brew install gcc
pip install scipy
brew install freetype
pip install matplotlib
pip install nose
pip install pandas
pip install sympy
pip install ipython[all]
brew install pyqt
brew install qt
brew install sip
#after this edit the 2 scripts
*** check if properly isntalled using .__version _ after import

using python snippets inside orgmode https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-python.html
installed python-mode from package-list-packages for emacs
#+BEGIN_SRC emacs-lisp
  (pyvenv-workon "mlm")
#+END_SRC

#+RESULTS:

Fixed some errors using: pip install nose pyparsing python-dateutil pep8
#+BEGIN_SRC python :results output
  import sys
  import scipy
  import numpy
  import matplotlib
  import pandas
  import sklearn

  print(f'python: {sys.version}')
  print(f'scipy: {scipy.__version__}')
  print(f'numpy: {numpy.__version__}')
  print(f'matplotlib {matplotlib.__version__}')
  print(f'pandas {pandas.__version__}')
  print(f'sklearn {sklearn.__version__}')

#+END_SRC

#+RESULTS:
: python: 3.7.2 (default, Dec 27 2018, 07:35:06) 
: [Clang 10.0.0 (clang-1000.11.45.5)]
: scipy: 1.1.0
: numpy: 1.15.4
: matplotlib 3.0.2
: pandas 0.23.4
: sklearn 0.20.1

** 2 - python, pandas, numpy, mathplotlib veeery basics

*** python, also refer in-y-minutes file for future reference
#+BEGIN_SRC python :results output
  if 1>2:
      print("wtf")
  else:
      print("ok")

  try:
      # Use "raise" to raise an error
      raise IndexError("This is an index error")
  except IndexError as e:
      print("its indexerror")
      pass                 # Pass is just a no-op. Usually you would do recovery here.
  except (TypeError, NameError):
      print("its typeerror or nameerror")
      pass                 # Multiple exceptions can be handled together, if required.
  else:                    # Optional clause to the try/except block. Must follow all except blocks
      print("All good!")   # Runs only if the code in try raises no exceptions
  finally:                 #  Execute under all circumstances
      print("We can clean up resources here")
#+END_SRC

#+RESULTS:
: ok
: its indexerror
: We can clean up resources here

#+BEGIN_SRC python :results output
  def accepts_variable_number_of_arguments(*args):
      print(type(args))
      print(args)

  accepts_variable_number_of_arguments(1,2,3)

  def accepts_variable_number_of_keyword_arguments(**kwargs):
      print(type(kwargs))
      print(kwargs)

  accepts_variable_number_of_keyword_arguments(name="anoop", work="code")

  def accepts_both_args_and_kwargs(*args, **kwargs):
      print(args)
      print("------")
      print(kwargs)

  accepts_both_args_and_kwargs(1,2,3,a="4",b="5",last0="6")
#+END_SRC

#+RESULTS:
: <class 'tuple'>
: (1, 2, 3)
: <class 'dict'>
: {'name': 'anoop', 'work': 'code'}

*** numpy basics

#+ATTR_ORG: :width 800px
[[file:screenshots0/Screenshot 2018-12-11 at 5.16.28 PM.png]]

*numpy official tutorial*
https://docs.scipy.org/doc/numpy-1.15.0/user/quickstart.html
#+BEGIN_SRC python :results output
    import numpy as np
    a = np.arange(15).reshape(3,5)
    print(a)
    a.shape
    a.ndim
    a.dtype.name
    #dir(a)
    a.size
    type(a)
    b = np.array([6,7,8])
    b
    type(b)

    np.zeros([2,3])
    np.arange(15)
    np.linspace(0,9, 19)

    from numpy import pi
    x = np.linspace(0, 2*pi, 5)
    np.sin(x)
    #2 decimal places
    np.around(np.sin(x), decimals=2)

    A = np.array([[1,2],[3,4]])
    I = np.array([[1,0],[0,1]])
    elementwise = A * I
    matrix_product = A @ I
    print(elementwise, "\n", matrix_product)

    a = np.ones(3, dtype=np.int32)
    b = np.linspace(0, 1, 3)
    c = a + b
    print(a,b,c)
    c.dtype.name
    c*1j
    np.ones(1)
    my_e = np.exp(np.ones(1))
    from numpy import e
    e
    print(e, my_e)
    d = np.exp(c*1j)
    d.dtype
    # exp, sin etc are called numpy universal functions

    # multidimensional array
  c = np.array([
      [
          [  0,  1,  2],
          [ 10, 12, 13]
      ],
      [
          [100,101,102],
          [110,112,113]
      ]
  ])
  c.shape
  # Visualize0 2,2,3 as you traverse from the topmost bracket to the inner ones
  for i in c.flat:
      print(i, end=" // ")
  print("\n")
  id(c) #id is unique identifier of an object in python


#+END_SRC

axis in numpy

#+ATTR_ORG: :width 800px
[[file:screenshots0/Screenshot%202018-12-11%20at%206.06.43%20PM.png][file:~/ml/flipshope/screenshots0/Screenshot 2018-12-11 at 6.06.43 PM.png]]

matplotlib python is not installed as a framework error, solution:
https://stackoverflow.com/questions/34977388/matplotlib-runtimeerror-python-is-not-installed-as-a-framework

Above is a hacky solution
I need to switch away from virtualenv & virtualenvwrapper and move to venv entirely
Also, reddit recommends to avoid the pyenv or any wrapper around venv && strongly recommends to use venv directly
venv ships by default with python >= 3.3
https://matplotlib.org/faq/osx_framework.html
https://news.ycombinator.com/item?id=18612590
https://news.ycombinator.com/item?id=18247512
:) 	
andybak 54 days ago [-]
In case this scares any new users, I've used nothing more than pip and virtualenv for several years with no issues of note.



#+BEGIN_SRC python :results output
  import numpy as np
  import matplotlib.pyplot as plt
  #import matplotlib  
  #matplotlib.use('TkAgg')   
  #import matplotlib.pyplot as plt 

  def mandelbrot( h,w, maxit=20 ):
      """Returns an image of the Mandelbrot fractal of size (h,w)."""
      y,x = np.ogrid[ -1.4:1.4:h*1j, -2:0.8:w*1j ]
      c = x+y*1j
      z = c
      divtime = maxit + np.zeros(z.shape, dtype=int)

      for i in range(maxit):
          z = z**2 + c
          diverge = z*np.conj(z) > 2**2            # who is diverging
          div_now = diverge & (divtime==maxit)  # who is diverging now
          divtime[div_now] = i                  # note when
          z[diverge] = 2                        # avoid diverging too much

      return divtime
  plt.imshow(mandelbrot(400,400))
  plt.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :results output
  import sys
  print(sys.path)
#+END_SRC

#+RESULTS:
: ['', '/Users/anoop/.virtualenvs/mlm/lib/python37.zip', '/Users/anoop/.virtualenvs/mlm/lib/python3.7', '/Users/anoop/.virtualenvs/mlm/lib/python3.7/lib-dynload', '/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7', '/Users/anoop/.virtualenvs/mlm/lib/python3.7/site-packages']

*real-python tutorial*
https://realpython.com/numpy-array-programming/

When it comes to computation, there are really three concepts that lend NumPy its power:
Vectorization
Broadcasting
Indexing

#+BEGIN_SRC python :results output
    import numpy as np

    arr = np.arange(36).reshape(3,4,3)
    arr

    """
    visualize0:-

    00 01 02 03 04 05 06 07 08 09 10 11 
    12 13 14 15 16 17 18 19 20 21 22 23 
    24 25 26 27 28 29 30 31 32 33 34 35 

    00 01 02 
    03 04 05 
    06 07 08 
    09 10 11 

    [#3 items
    [#4 items
    []
    []
    []
    []
    ]...
    ]
    """
    a = np.array([2,3,4])
    b = 2
    b_broadcasted = np.broadcast(a,b)
    print(list(b_broadcasted))
    # rest of this tutorial seemed a bit advanced, skip for now, come back later

#+END_SRC

*Note* Pandas is a library built on top of NumPy

todo: switch to jupyter notebook instead of emacs: 
https://github.com/millejoh/emacs-ipython-notebook
http://millejoh.github.io/emacs-ipython-notebook/
https://www.youtube.com/watch?v=wtVF5cMhBjg
https://news.ycombinator.com/item?id=9728143
https://github.com/gregsexton/ob-ipython

*** matplotlib basics
matplotlib, is written in pure Python and is heavily dependent on NumPy

Matplotlib is conceptually divided into three parts:
pylab interface (similar to MATLAB) – pylab tutorial, this is the matplotlib.pyplot import
Matplotlib frontend or API – artist tutorial
backends – drawing devices or renderers

Lets learn pyplot
https://matplotlib.org/users/pyplot_tutorial.html#pyplot-tutorial

venv basics to switch from virtualenv

python3 -m venv mlm2
source mlm2/bin/activate
# inside emacs do pyvenv-activate and provide the mlm2 directory
pyvenv-deactivate

#+BEGIN_SRC python :results both
  import matplotlib
  #matplotlib.use('MacOSX')
  import matplotlib.pyplot as plt

  plt.plot([0, 1, 4, 9, 16])
  #plt.show()

  plt.plot([0, 1, 4, 9, 16], 'ro')
  #plt.show()

  plt.plot([0.5], 'y.')
  plt.show()

#+END_SRC

#+RESULTS:
: None

*** Pandas -basics:
Todo:https://pandas.pydata.org/pandas-docs/stable/dsintro.html#dsintro
Todo:Official beginner tutorial: https://pandas.pydata.org/pandas-docs/stable/10min.html
Todo: Intermediate - Julia Evans - https://jvns.ca/blog/2013/12/22/cooking-with-pandas/
"take a real dataset or three, play around with it, and learn how to use pandas along the way."


Panda Series & DataFrames:
https://medium.freecodecamp.org/series-and-dataframe-in-python-a800b098f68
#+BEGIN_SRC python :results output
  #Series and DataFrames
  import pandas as pd
  x1 = pd.Series([6,3,4,6])
  x = pd.Series([6,3,4,6], index=['a','b','c','d'])
  x
  y = pd.Series(3, index=['a', 'b', 'c', 'd'])
  y

  #DataFrames
  import numpy as np
  dates = pd.date_range('20181201', periods = 8)

  my_narray = np.random.randn(8,3)
  list('ABC')

  df = pd.DataFrame(index = dates, data = my_narray, columns = ['A','B','C'])
  df_absolute = df.apply(abs)
#+END_SRC

So pandas is kinda like an excel sheet0

#+BEGIN_SRC python :results output
  import numpy as np

  np.arange(4)
  ma = np.arange(4).reshape((2,2))

  import pandas

  p = pandas.DataFrame(ma)

  print(ma[1,0])
  print(p[1])
  print(p[1][0] == ma[1][0])
  print(p.shape)


#+END_SRC

*** also refer to (I did not use this though) https://machinelearningmastery.com/crash-course-python-machine-learning-developers/
** 3 - Load csv
https://realpython.com/python-csv/
https://github.com/jbrownlee/Datasets

*Work with csv using python's csv module*
#+BEGIN_SRC python :results output
  import csv

  with open('iris.csv') as csv_file:
      """
      for line in csv_file:
          print(line)
          pass
      """
      csv_reader = csv.reader(csv_file)
      for line in csv_reader:
          #print(line)
          pass

  my_fieldnames = ("sepal_length", "sepal_width", "petal_length", "petal_width", "class")

  with open('iris.csv') as csv_file:
      csv_dict_reader = csv.DictReader(csv_file, fieldnames=my_fieldnames)
      for line in csv_dict_reader:
          #print(line)
          pass

  with open('test_writeout.csv', mode='w') as out_file:
      csv_writer = csv.writer(out_file)
      csv_writer.writerow(["row", "1"])
      csv_writer.writerow(["row", "2"])
      #
      csv_dict_writer = csv.DictWriter(out_file, fieldnames = my_fieldnames)
      csv_dict_writer.writeheader()
      csv_dict_writer.writerow({"sepal_length": 1, "sepal_width": 2, "petal_length": 3, "petal_width": 4, "class": 5})


#+END_SRC

*Work with csv using numpy*
#+BEGIN_SRC python :results output
  import numpy as np

  with open("numpy_loadtxt_input.txt") as input_file:
      """
      for line in input_file:
          print(line)
      """
      my_nparray = np.loadtxt(input_file, delimiter=" ")
      print(my_nparray)
      print(my_nparray.dtype)
#+END_SRC

#+RESULTS:
: [[0. 1.]
:  [2. 3.]]
: float64

*Work with csv usign pandas*
#+BEGIN_SRC python :results output
  import pandas
  df = pandas.read_csv('pandas_read_csv.csv')
  print(df)

  df2 = pandas.read_csv('pandas_read_csv.csv', parse_dates=[
                        'Hire Date'], index_col='Name')
  print(df2)

  my_col_names = ("Name", "Hired_on", "Salary", "sick_days_remaining")
  df3 = pandas.read_csv('pandas_read_csv.csv', header=None, names=my_col_names,
                        parse_dates=['Hired_on'])
  print(df3)

  df3.to_csv('pandas_to_csv.csv')
#+END_SRC


** 4 - use pandas.DataFrame helper functions to describe data with statistics
#+BEGIN_SRC python :results output
  # Scatter Plot Matrix
  import matplotlib.pyplot as plt
  import pandas

  my_col_names = ("num_preg", "plasma_glucose", "blood_pressure", "triceps_skin_thickness", "serum_insulin", "bmi", "diabetes_pedigree", "age", "class")
  df = pandas.read_csv("https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.data.csv", header=None, names=my_col_names)
  #print(df)

  from pandas.plotting import scatter_matrix

  scatter_matrix(df)
  plt.show()

  df.corr()
#+END_SRC

#+RESULTS:

** 5 - Basic Data Visualization
Using pandas and matplotlib together
#+BEGIN_SRC python :results file
  # Scatter Plot Matrix
  import matplotlib.pyplot as plt
  import pandas

  my_fieldnames = ("sepal_length", "sepal_width", "petal_length", "petal_width", "class")
  data = pandas.read_csv('iris.csv', names=my_fieldnames)
  #print(data)

  se = data.loc[data["class"] == "Iris-setosa"]
  ve = data.loc[data["class"] == "Iris-versicolor"]
  vi = data.loc[data["class"] == "Iris-virginica"]

  #se.hist()
  #ve.hist()
  #vi.hist()

  se.plot(kind="box")

  from pandas.plotting import scatter_matrix
  #scatter_matrix(se)

  plt.savefig("img/lesson5.png")
  return "img/lesson5.png"
#+END_SRC

#+RESULTS:
[[file:img/lesson5.png]]


** 6 - Preprocessing data

Standardize numerical data (e.g. mean of 0 and standard deviation of 1) using the scale and center options.

Simple example:
#+BEGIN_SRC python :results output
  import numpy
  narray = numpy.arange(0,4).reshape(2,2)

  import pandas
  df = pandas.DataFrame(narray, columns=("c1", "c2"))

  from sklearn.preprocessing import StandardScaler
  scaler = StandardScaler()
  scaler.fit(df) #calculates and store mean & standard-deviation for each column

  print(scaler.transform(df))
  type(scaler.transform(df))
  df_standardized = pandas.DataFrame(scaler.transform(df))
#+END_SRC

Complex example:
#+BEGIN_SRC python :results output
  import matplotlib.pyplot as plt
  import pandas

  #df is my short for DataFrame
  my_col_names = ("num_preg", "plasma_glucose", "blood_pressure", "triceps_skin_thickness", "serum_insulin", "bmi", "diabetes_pedigree", "age", "class")
  df = pandas.read_csv("https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.data.csv", header=None, names=my_col_names)
  #print(df)

  import numpy
  array = df.values

  X = array[:, :-1]
  Y = array[:, -1:]

  from sklearn.preprocessing import StandardScaler
  scaler = StandardScaler().fit(X)
  X_standardized = scaler.transform(X)

  #printout
  numpy.set_printoptions(precision=2)
  print(X_standardized)

  df_standardized = pandas.DataFrame(X_standardized)
  df_standardized.describe() #you can see that mean=0, sdev=1 for each column

#+END_SRC


*** skip for now, come back later
Normalize numerical data (e.g. to a range of 0-1) using the range option.
Explore more advanced feature engineering such as Binarizing.

** 7 - Resampling
 statistical methods called resampling methods are used to split your training
 dataset up into subsets, some are used to train the model and others
 are held back and used to estimate the accuracy of the model on
 unseen data.

** Google Developers intro to ml
complete google developers course, its a pre-requisite for this lesson as per me
https://www.youtube.com/playlist?list=PLOU2XLYxmsIIuiBfYad6rFYQU_jL2ryal

*** 1 hello apple or orange using decision tree
#+BEGIN_SRC python :results output
  from sklearn import tree
  features_original = [[140, "smooth"], [130, "smooth"], [150, "bumpy"], [170, "bumpy"]] #weight, texture of fruit
  labels_original = ["apple", "apple", "orange", "orange"]

  #smooth=1 // bumpy=0
  #orange=1 // apple=0
  features = [[140, 1], [130, 1], [150, 0], [170, 0]] #weight, texture of fruit
  labels = [0, 0, 1, 1]

  #train a classifier: 
  clf = tree.DecisionTreeClassifier() #instantiate an empty box of rules
  clf = clf.fit(features, labels) #learning algorithm fills the above box with rules

  #print(clf.predict([[150,0]]))
  print(clf.predict([[200,0]]))
#+END_SRC


*** 2 Decision Tree visualization

#+BEGIN_SRC python :results file
  from sklearn.datasets import load_iris
  from sklearn import tree
  iris = load_iris()
  print(dir(iris))

  print(iris.feature_names) #in this example data_names is more suitable
  print(iris.data[0])

  print(iris.target_names)
  print(iris.target)

  #Resampling:
  test_ids = [0,50,100]

  import numpy as np

  #training data
  train_target = np.delete(iris.target, test_ids)
  train_data = np.delete(iris.data, test_ids, axis=0)

  #testing data
  test_target = iris.target[test_ids]
  test_data = iris.data[test_ids]

  clf = tree.DecisionTreeClassifier()
  clf.fit(train_data, train_target)

  predicted_target = clf.predict(test_data)
  print(f"Reality: {test_data} features is {test_target}")
  print(f"Prediction: {test_data} has been predicted as {predicted_target}")

  #Visualize: https://medium.com/@rnbrown/creating-and-visualizing-decision-trees-with-python-f8e8fa394176
  from sklearn.externals.six import StringIO  
  from sklearn.tree import export_graphviz
  import pydotplus

  dot_data = StringIO() #StringIO() behaves like a file
  export_graphviz(clf, out_file=dot_data, feature_names=iris.feature_names, class_names=iris.target_names)
  graph = pydotplus.graph_from_dot_data(dot_data.getvalue())  
  graph.write_png("img/iris.png")
  return "img/iris.png"
#+END_SRC 
#+ATTR_ORG: :width 800px
#+RESULTS:
[[file:img/iris.png]]




** 7 - Resampling

*** https://machinelearningmastery.com/k-fold-cross-validation/
Shuffle the dataset randomly.
Split the dataset into k groups
For each unique group:
Take the group as a hold out or test data set
Take the remaining groups as a training data set
Fit a model on the training set and evaluate it on the test set
Retain the evaluation score and discard the model
Summarize the skill of the model using the sample of model evaluation scores


k-fold cross validation
leave one out cross validation = n-fold cross validation

Train/Test Split: = 1-fold cross validation
(Taken to one extreme, k may be set to 1 such that a single train/test split is created to evaluate the model.)

To summarize, there is a bias-variance trade-off associated with the
choice of k in k-fold cross-validation. Typically, given these
considerations, one performs k-fold cross-validation using k = 5 or k
= 10, as these values have been shown empirically to yield test error
rate estimates that suffer neither from excessively high bias nor from
very high variance.

KFold() scikit-learn class can be used

#+BEGIN_SRC python :results file
  from sklearn.model_selection import KFold
  import numpy

  array = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]
  na = numpy.array(array)

  my_kfold = KFold(n_splits=3, shuffle=True, random_state=6)

  #split method generates the indices
  for train, test in my_kfold.split(na):
      print("indices for train and test respectively", train, test)
      print("actual train and test data respectively", na[train], na[test])
      print()

#+END_SRC

#+RESULTS:
[[file:None]]


*** Example = apply 10-fold to diabetes data
use scikit-learn to estimate the accuracy of the Logistic Regression
algorithm on the Pima Indians onset of diabetes dataset using 10-fold
cross validation.

#+ATTR_ORG: :width 800px
Emacs help: [[file:screenshots0/Screenshot%202018-12-13%20at%2012.57.01%20PM.png][file:~/ml/flipshope/screenshots0/Screenshot 2018-12-13 at 12.57.01 PM.png]]
I used decision tree to fit this data
#+BEGIN_SRC python :results file
  import pandas as pd
  my_names = ['preg', 'plas', 'pres', 'skin', 'test', 'mass', 'pedi', 'age', 'class']
  df = pd.read_csv("https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.data.csv", names=my_names)

  array = df.values
  print(array)

  features = array[:,:-1]
  is_diabetic = array[:,-1:]

  from sklearn.model_selection import cross_val_score
  from sklearn.model_selection import KFold

  my_kfold = KFold(n_splits=10, random_state=6)

  #my_kfold.split(features)
  """
  X = []
  y = []
  clf = tree.DecisionTreeClassifier()
  clf.fit(X, y)
  print("prediction:", clf.predict(X_test), " // actual:", y_test)
  """
  from sklearn import tree
  clf = tree.DecisionTreeClassifier()
  results = cross_val_score(clf, features, is_diabetic, cv=my_kfold)
  print(f"Mean accuracy: {results.mean()}, Sdev: {results.std()}")
#+END_SRC
#+ATTR_ORG: :width 800px


Example given on website use LogisticRegression
#+BEGIN_SRC python :results file
  # Evaluate using Cross Validation
  from pandas import read_csv
  from sklearn.model_selection import KFold
  from sklearn.model_selection import cross_val_score
  from sklearn.linear_model import LogisticRegression
  url = "https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.data.csv"
  names = ['preg', 'plas', 'pres', 'skin', 'test', 'mass', 'pedi', 'age', 'class']
  dataframe = read_csv(url, names=names)
  array = dataframe.values
  X = array[:,0:8]
  Y = array[:,8]
  kfold = KFold(n_splits=10, random_state=7)
  model = LogisticRegression()
  results = cross_val_score(model, X, Y, cv=kfold)

  print(f"Mean accuracy: {results.mean()}, Sdev: {results.std()}")

#+END_SRC
#+ATTR_ORG: :width 800px

** 8 - Algorithm evaluation metrics
stopped this lesson in between and skipped for now
https://machinelearningmastery.com/metrics-evaluate-machine-learning-algorithms-python/

*Contents of this lesson:*
/You will learn about 3 classification metrics:/
Accuracy.
Logarithmic Loss.
Area Under ROC Curve.

/Also 2 convenience methods for classification prediction results:/
Confusion Matrix.
Classification Report.

/And 3 regression metrics:/
Mean Absolute Error.
Mean Squared Error.
R^2.

Classification metrics
-for problems like diabetic or not (binary classification 0 or 1 is 'class')

Regression metrics
-for problems like boston house pricing (continuous price metric is 'class')

All recipes evaluate the same algorithms, Logistic Regression for
classification and Linear Regression for the regression problems

*** Classification Metrics
Apply Logistic Regression to diabetes problem and watch how each algo evaluation recipe works
keeping the algo constant

Recipes:
**** Classification Accuracy.
#+BEGIN_SRC python :results file
  import pandas

  feature_names = ["pregnant", "plasma_glucose", "blood_pressure", 
                   "skin_fold_thickness", "serum_insulin", "bmi", "pedigree", "age", "class"]

  df = pandas.read_csv("https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.data.csv", 
                       names = feature_names)

  array = df.values
  X = array[:, :-1]
  #y = array[:, -1:] #common mistake made by anoop

  #What we are after is a single row for y
  y = array[:, -1]

  from sklearn.model_selection import KFold
  from sklearn.model_selection import cross_val_score

  my_kfold = KFold(n_splits=10, random_state=6)

  from sklearn.linear_model import LogisticRegression
  my_estimator_model = LogisticRegression()

  # scoring="name_of_algorithm_evaluation_metric0" refer to https://scikit-learn.org/stable/modules/model_evaluation.html
  results = cross_val_score(my_estimator_model, X, y, cv=my_kfold, scoring="accuracy")

  print(f"mean accuracy of diabetes predicition mu = {results.mean()}, sdev = {results.std()}")
#+END_SRC
#+ATTR_ORG: :width 800px
**** Logarithmic Loss.
Some evaluation metrics (like mean squared error) are naturally
descending scores (the smallest score is best) and as such are
reported as negative by the cross_val_score() function. This is
important to note, because some scores will be reported as negative
that by definition can never be negative.

The theory of this I havent yet understood, skip for now
http://wiki.fast.ai/index.php/Log_Loss

#+BEGIN_SRC python :results file
  scoring = "neg_log_loss"
  #use above value in model_selection.cross_val_score()

#+END_SRC
#+ATTR_ORG: :width 800px
**** Area Under ROC Curve.
**** Confusion Matrix.
**** Classification Report.
Making use of convenience feature in sklearn
#+BEGIN_SRC python :results file
from sklearn.metrics import classification_report
#+END_SRC
#+ATTR_ORG: :width 800px

*** Regression Metrics
Mean Absolute Error.
Mean Squared Error.
R^2.

** 9 - Spot checking
*** https://machinelearningmastery.com/spot-check-classification-machine-learning-algorithms-python-scikit-learn/

We will spot check 6 classification algorithms

*2 Linear Machine Learning Algorithms:*
Logistic Regression, lr                 ;;;; NOTE: ALTHOUGH ITS A CLASSIFICATION PROBLEM, THIS MODEL STILL HAS /'Regression'/ IN ITS NAME
Linear Discriminant Analysis, lda

*4 Nonlinear Machine Learning Algorithms:*
K-Nearest Neighbors, knn
Naive Bayes, nb
Decision Trees (or Classification and Regression Trees, CART), in this case we will use classification tree
Support Vector Machines, svm

Lets try out on pima-indians-diabetes
Lets suppose that mean() accuracy on 10-fold cross validation represents the performance of each algorithm

DOUBT
A note about sklearn.model_selection.cross_val_score() function:
If no scoring is specified, the estimator(classifier) passed should have a 'score' method
https://github.com/scikit-learn/scikit-learn/blob/14031f6/sklearn/model_selection/_validation.py#L36

"By default, the score computed at each CV iteration is the score
method of the estimator. It is possible to change this by using the
scoring parameter." 
https://stackoverflow.com/questions/42825714/what-is-the-score-function-formula-of-sklearn-model-selection-cross-val-score

DOUBT ENDS

#+BEGIN_SRC python :results output
  import pandas

  feature_names = ["pregnant", "plasma_glucose", "blood_pressure", 
                   "skin_fold_thickness", "serum_insulin", "bmi", "pedigree", "age", "class"]
  df = pandas.read_csv("https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.data.csv", names=feature_names)

  array = df.values

  features = array[:, :-1]
  is_diabetic = array[:, -1]

  from sklearn.model_selection import KFold
  from sklearn.model_selection import cross_val_score
  from sklearn.linear_model import LogisticRegression

  my_kfold = KFold(n_splits=10, random_state=6)
  classifier_lr = LogisticRegression()

  results_logistic_regression = cross_val_score(classifier_lr, features, is_diabetic, cv=my_kfold)
  print("lr: ", results_logistic_regression.mean(), results_logistic_regression.std())

  from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
  classifier_lda = LinearDiscriminantAnalysis()
  results_linear_discriminant_analysis = cross_val_score(classifier_lda, features, is_diabetic, cv=my_kfold)
  print("lda: ", results_linear_discriminant_analysis.mean(), results_linear_discriminant_analysis.std())

  from sklearn.neighbors import KNeighborsClassifier
  classifier_knn = KNeighborsClassifier()
  results_knn = cross_val_score(classifier_knn, features, is_diabetic, cv=my_kfold)
  print("knn: ", results_knn.mean(), results_knn.std())

  from sklearn.naive_bayes import GaussianNB
  classifier_nb = GaussianNB()
  results_nb = cross_val_score(classifier_nb, features, is_diabetic, cv=my_kfold)
  print("nb: ", results_nb.mean(), results_nb.std())

  from sklearn.tree import DecisionTreeClassifier
  classifier_dt = DecisionTreeClassifier()
  results_dt = cross_val_score(classifier_dt, features, is_diabetic, cv=my_kfold)
  print("dt: ", results_dt.mean(), results_dt.std())

  from sklearn.svm import SVC
  classifier_svc = SVC()
  results_svc = cross_val_score(classifier_svc, features, is_diabetic, cv=my_kfold)
  print("svc: ", results_svc.mean(), results_svc.std())

#+END_SRC

#+RESULTS:
: lr:  0.7760423786739576 0.051575452620868226
: lda:  0.773462064251538 0.05159180390446138
: knn:  0.7265550239234451 0.06182131406705549
: nb:  0.7551777170198223 0.04276593954064409
: dt:  0.7043233082706767 0.06725181687871121
: svc:  0.6510252904989747 0.07214083485055327

#+ATTR_ORG: :width 800px


Note:python submodule doubt
https://stackoverflow.com/questions/12229580/python-importing-a-sub-package-or-sub-module
Try it out yourself
#+BEGIN_SRC python :results file
  import sklearn
  dir(sklearn)
  import sklearn.discriminant_analysis
  dir(sklearn) #now more things are shown, why?
#+END_SRC
#+ATTR_ORG: :width 800px


*** https://machinelearningmastery.com/spot-check-regression-machine-learning-algorithms-python-scikit-learn/
We will spot check 7 regression algorithms

*4 Linear Machine Learning Algorithms:*
Linear Regression
Ridge Regression
LASSO Linear Regression
Elastic Net Regression

*3 Nonlinear Machine Learning Algorithms:*
K-Nearest Neighbors
Classification and Regression Trees, in this case we will use regression tree
Support Vector Machines

Lets try out on boston-house-pricing
Lets suppose that the negative mean squared error measures on 10-fold cross validation represents the performance of each algorithm

#+BEGIN_SRC python :results output
  import pandas

  data_names = ("crim", "zn", "indus", "chas", "nox", "rm", "age", "dis", "rad", "tax", "ptratio", "b", "lstat", "medv")
  df = pandas.read_csv("https://raw.githubusercontent.com/anoopemacs/Datasets/master/housing.csv", names=data_names)
  #chas is binary, rest are all continuous features

  array = df.values
  features = array[:, :-1] #X
  house_value = array[:, -1] #y

  from sklearn.model_selection import KFold
  my_kfold = KFold(n_splits=10, random_state=6)
  from sklearn.model_selection import cross_val_score

  #LINEAR REGRESSION MODELS x 4

  from sklearn.linear_model import LinearRegression
  estimator_lr = LinearRegression()
  results_lr = cross_val_score(estimator_lr, features, house_value, scoring="neg_mean_squared_error", cv=my_kfold)
  print("lr: ", results_lr.mean())

  from sklearn.linear_model import Ridge
  estimator_rr = Ridge()
  results_rr = cross_val_score(estimator_rr, features, house_value, scoring="neg_mean_squared_error", cv=my_kfold)
  print("rr: ", results_rr.mean())

  from sklearn.linear_model import Lasso
  estimator_lasso = Lasso()
  results_lasso = cross_val_score(estimator_lasso, features, house_value, scoring="neg_mean_squared_error", cv=my_kfold)
  print("lasso: ", results_lasso.mean())

  from sklearn.linear_model import ElasticNet
  estimator_elasticnet = ElasticNet()
  results_elasticnet = cross_val_score(estimator_elasticnet, features, house_value, scoring="neg_mean_squared_error", cv=my_kfold)
  print("elasticnet: ", results_elasticnet.mean())

  #NON LINEAR MODELS x 3
  from sklearn.neighbors import KNeighborsRegressor
  estimator_knn = KNeighborsRegressor()
  results_knn = cross_val_score(estimator_knn, features, house_value, scoring="neg_mean_squared_error", cv=my_kfold)
  print("knn: ", results_knn.mean())

  from sklearn.tree import DecisionTreeRegressor
  estimator_cart = DecisionTreeRegressor()
  results_cart = cross_val_score(estimator_cart, features, house_value, scoring="neg_mean_squared_error", cv=my_kfold)
  print("cart: ", results_cart.mean())

  from sklearn.svm import SVR
  estimator_svr = SVR()
  results_svr = cross_val_score(estimator_svr, features, house_value, scoring="neg_mean_squared_error", cv=my_kfold)
  print("svr: ", results_svr.mean())
#+END_SRC
#+ATTR_ORG: :width 800px
*** How to Develop a Reusable Framework to Spot-Check Algorithms in Python:
https://machinelearningmastery.com/spot-check-machine-learning-algorithms-in-python/
This is an important lesson, indirectly I will also learn how to write/maintain my own python module as well
But skip for now as I want to come back to topics like this in a second revision




** 10 - Model selection by comparison between models
Advice to beginners from JSAT java ml package author edward raff:
http://jsatml.blogspot.com/2014/10/beginner-advice-on-learning-to.html
His book recommendations: 

*The Elements of Statistical Learning*
This is a very common book for people to learn and get, especially
since it is free. In my opinion, the book isn't particularly great in
any area – but its not particularly bad at anything either. Though if
you are more of a visual learner this book has lots of graphs and
diagrams to try and give intuitions of how things work / what's going
on. If your goal is to implement for learning, recreating their
visual results would be an excellent exercise.

*Machine learning: a Probabilistic Perspective*
This is currently my favorite ML book. Murphy does an excellent job
explain the algorithms, and relating them to each other to help foster
a deeper understanding. Though the learning curve is a bit wonky at
times, and the later chapters don’t have quite as much lower level
details – its overall excellent. For implementing in particular, much
more refined (and explained) pseudo code is present for many of the
algorithms and for many of the chapters and algorithms goes through
the math needed to develop these algorithms. Occasionally some
implementation considerations are discussed. While not often, it is
more than most books on Machine Learning.

https://machinelearningmastery.com/compare-machine-learning-algorithms-python-scikit-learn/

For fair comparision of algorithms use the same random_state=seed=6

Lets compare the following on binary classification of pima-indians-diabetes dataset
LR: Logistic Regression
LDA: Linear Discriminant Analysis
KNN: K-Nearest Neighbors
CART: Classification and Regression Trees
NB: Naive Bayes
SVM: Support Vector Machines

*NOTE: trick to use to find dir(sklearn) doesnt give all submodules,*
use linux ls:
ls /Users/anoop/ml/flipshope/mlm2/lib/python3.7/site-packages/sklearn/

#+BEGIN_SRC python :results file
  #hide warnings
  def warn(*args, **kwargs):
      pass
  import warnings
  warnings.warn = warn

  import pandas
  data_names = ["pregnant", "plasma_glucose", "blood_pressure", 
                "skin_fold_thickness", "serum_insulin", "bmi", "pedigree", "age", "class"]
  df = pandas.read_csv("https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.data.csv", names=data_names)

  print(df.shape)

  array = df.values
  features = array[:, :-1]
  is_diabetic = array[:, -1]

  #print(features)
  #print(is_diabetic)

  from sklearn.model_selection import KFold
  my_kfold = KFold(n_splits=10, random_state=6)

  from sklearn.model_selection import cross_val_score

  models = []

  from sklearn.linear_model import LogisticRegression
  models.append(("LR", LogisticRegression()))

  from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
  models.append(("LDA", LinearDiscriminantAnalysis()))

  from sklearn.neighbors import KNeighborsClassifier
  models.append(("KNN", KNeighborsClassifier()))

  from sklearn.tree import DecisionTreeClassifier
  models.append(("CART", DecisionTreeClassifier()))

  from sklearn.naive_bayes import GaussianNB
  models.append(("NB", GaussianNB()))

  from sklearn.svm import SVC
  models.append(("SVM", SVC()))

  results = []
  model_names = []

  for (name, model) in models:
      #print(name, model)
      try:
          result = cross_val_score(model, features, is_diabetic, cv=my_kfold, scoring='accuracy')
          #print(name, ": ", result.mean(), " // ", result.std())
          results.append(result)
          model_names.append(name)
      except Exception:
          print(name)
          continue

  print(model_names)
  print(results)
  import numpy


  from matplotlib import pyplot
  pyplot.boxplot(results, labels=model_names)
  #pyplot.show()
  pyplot.savefig("img/model-selection-by-comparison.png")
  return "img/model-selection-by-comparison.png"
#+END_SRC

#+RESULTS:
[[file:img/model-selection-by-comparison.png]]

#+ATTR_ORG: :width 800px

From the above fig it seems like for this problem, at first glance it seems
like LR and LDA sound promising for further evaluation



** 11 - Improve accuracy by tuning the selected algorithm
2 ways:
Tune the parameters of an algorithm using a grid search that you specify.
Tune the parameters of an algorithm using a random search.

#+BEGIN_SRC python :results both
  import pandas
  data_names = ["pregnant", "plasma_glucose", "blood_pressure", 
                "skin_fold_thickness", "serum_insulin", "bmi", "pedigree", "age", "class"]
  df = pandas.read_csv("https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.data.csv", names=data_names)

  array = df.values
  X = array[:, :-1]
  y = array[:, -1]

  from sklearn.linear_model import Ridge
  classifier = Ridge()

  from sklearn.model_selection import GridSearchCV
  my_param_grid = {"alpha" : [1, 0.1, 0.01, 0.001, 0.0001, 0]}

  grid = GridSearchCV(classifier, param_grid = my_param_grid)
  grid.fit(X, y)

  print(grid.best_score_)
  print(grid.best_estimator_.alpha)

  ################################################################

  from sklearn.model_selection import RandomizedSearchCV
  classifier2 = Ridge()

  from scipy.stats import randint
  my_param_dist = {"alpha": randint(0,10)} #doubt, can alpha be > 1, also wtf is scipy.stats.randint() function
  random_search = RandomizedSearchCV(estimator=classifier2, param_distributions = my_param_dist)
  random_search.fit(X, y)
  print(random_search.best_estimator_)

#+END_SRC

#+RESULTS:
: None

#+ATTR_ORG: :width 800px

** 12 - Improve accuracy with Ensemble Predictions
combine predictions from multiple models

Practice bagging ensembles with the random forest and extra trees algorithms.
Practice boosting ensembles with the gradient boosting machine and AdaBoost algorithms.
Practice voting ensembles using by combining the predictions from multiple models together.

skip for now till you understand what is bagging and stochastic gradient boosting

** 13 - Saving model to file for future reuse
We use 'pickle' to save model to file
#+BEGIN_SRC python :results file
  import pickle
  from sklearn.linear_model import LogisticRegression
  from sklearn.model_selection import train_test_split
  import pandas
  data_names = ["pregnant", "plasma_glucose", "blood_pressure",
                "skin_fold_thickness", "serum_insulin", "bmi", "pedigree", "age", "class"]
  df = pandas.read_csv(
      "https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.data.csv", names=data_names)

  array = df.values
  X = array[:, :-1]
  y = array[:, -1]


  X_train, X_test, y_train, y_test = train_test_split(X, y)

  my_estimator = LogisticRegression()  # this is the model

  my_estimator.fit(X_train, y_train)

  # save trained model to disk for reuse
  # alternative is to use with open syntax
  pickle.dump(my_estimator, open("lesson13_saved_model.sav", 'wb'))
  # wb = write binary

  # later on
  # loading from saved binary data on file
  loaded_model = pickle.load(open("lesson13_saved_model.sav", "rb"))

  # saved model try on test data
  result = loaded_model.score(X_test, y_test)
  print(result)
#+END_SRC
#+ATTR_ORG: :width 800px

** 14 - end to end
skip for now, later on pick something from UCI dataset and do on your own
after some spaced repetition

* NumPy
*realpython says:*
When it comes to computation, there are really three concepts that lend NumPy its power:
Vectorization = "I think there is room for a different approach concentrating on the migration from Python to Numpy through vectorization" http://www.labri.fr/perso/nrougier/from-python-to-numpy/
Broadcasting
Indexing

Studying from scipy-lectures Chapter 1.3 

** Concise notes on section 1.3.1. The NumPy array object
#+BEGIN_SRC python :results file
  import matplotlib.pyplot as plt
  import numpy as np

  # np.con*?  # only in ipython?
  a = np.array([1, 2, 3, 4])
  a.ndim
  a.shape

  np.arange(1, 10)
  np.linspace(0, 1, 3, endpoint=True)

  np.ones((3, 4))
  np.zeros((2, 3))
  np.eye(4)
  d = np.diag(a)

  np.random.rand(2, 2)  # input is shape

  x = np.linspace(0, 5, num=6)
  plt.plot(x, x ** 2, 'o')

  image = np.random.rand(30, 30)
  plt.imshow(image)

  # Indexing and Slicing, # a[start:stop:step]
  d[1:, :]  # index is a tuple, but dont put () because : syntax is for numpy

  idwala = np.arange(6) + np.arange(0, 51, 10)[:, np.newaxis]
  np.tile(np.array([[4, 3], [2, 1]], dtype=np.int64), (2, 3))

  e = d.copy()
  np.may_share_memory(d, e)  # => False

  # eratostenes seive implement

  # Fancy indexing, unlike above slicing & simple indexing, this always creates copies
  mask = (d != 0)
  f = d[mask]

  idwala[[2, 1, 1], [0, 3, 3]]
  idwala[1:5:2, [0, 2, 4]]

  #bool np.array used as mask, note:doesnt work if mask isnt dtype=bool
  mask = np.array([1, 0, 1, 0, 0, 1], dtype=bool)
  idwala[mask, [0,2,5]] #shows the red ones
#+END_SRC
#+ATTR_ORG: :width 800px
file:///Users/anoop/ml/flipshope/scipy-lecture-notes/scipy-lectures-scipy-lectures.github.com-4b1d444/_images/numpy_fancy_indexing.png

*** eratostenes seive doubt
Doubt: How to add the optimization to skip if already False inside for loop?
#+BEGIN_SRC python :results file
  import numpy as np
  ans = np.array([ 2,  3,  5,  7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])
  is_prime = np.ones(100, dtype=bool)
  is_prime[:2] = False

  N_max = int(np.sqrt(99)) #the max value in is_prime

  for j in range(2, N_max):
      is_prime[j*j::j] = False

  my_ans = np.nonzero(is_prime)
  np.array_equal(my_ans[0], ans)

#+END_SRC
#+ATTR_ORG: :width 800px

possible ans
#+BEGIN_SRC python :results file
  def primesfrom3to(n):
      # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188
      """ Returns a array of primes, p < n """
      assert n>=2
      sieve = np.ones(n/2, dtype=np.bool)
      for i in xrange(3,int(n**0.5)+1,2):
          if sieve[i/2]:
              sieve[i*i/2::i] = False
      return np.r_[2, 2*np.nonzero(sieve)[0][1::]+1]  


  ##original
  import numpy
  def primesfrom3to(n):
      """ Returns a array of primes, 3 <= p < n """
      sieve = numpy.ones(n//2, dtype=numpy.bool)
      for i in range(3,int(n**0.5)+1,2):
          if sieve[i//2]:
              sieve[i*i//2::i] = False
      return 2*numpy.nonzero(sieve)[0][1::]+1
#+END_SRC
#+ATTR_ORG: :width 800px

** Concise notes on section 1.3.2. Numerical operations on arrays
Mn. elementwise is the name of the game
#+BEGIN_SRC python :results file
  from matplotlib import pyplot as plt
  import numpy as np

  # Generate a_j = 2^(3*j) - j
  a10 = np.arange(0, 10)
  2 ** (3 * a10) - a10

  a = np.ones(4, dtype=bool)
  b = np.zeros(4, dtype=bool)

  a == b  # elementwise, returns array of bool
  np.array_equal(a, b)  # arraywise
  np.logical_or(a, b)
  np.logical_and(a, b)

  x = np.linspace(0, 2*3.14, 5)
  y = np.sin(x)

  x2 = np.linspace(0, 2*3.14, 50000, endpoint=True)
  y2 = np.sin(x2)

  # lly, np.log(...)  np.exp(...)

  # np.triangle upper
  a = np.triu(np.ones((3, 3)), 1)
  b = a.T
  np.may_share_memory(a, b)

  # np.allclose?

  # Reductions:
  a.sum(axis=0)
  # lly a.max(), a.min(), a.argmax(), a.argmin(), a.any(), a.all()
  # a.mean(), a.std()

  # logical operation used for reduction nice example
  a = np.array([1, 2, 3, 2])
  b = np.array([2, 2, 3, 2])
  c = np.array([6, 4, 4, 5])

  ((a <= b) & (b <= c)).all()

  # data visualization & stats worked example, hares etc populaitons

  data = np.loadtxt('./populations.txt')
  year, hare, lynx, carrot = data.T  # awesome trick <3
  plt.plot(year, hare, year, lynx, year, carrot)
  plt.legend(('Hare', 'Lynx', 'Year'))
  # plt.show()

#+END_SRC
#+ATTR_ORG: :width 800px

use scipy.linalg, not numpy.linalg : because scipy version is guranteed to fast

try again after spaced repetition: Worked Example: diffusion using a random walk algorithm

*** Broadcasting
Same size expansion

Very useful trick: a = a[:, np.newaxis]  # adds a new axis -> 2D array if 1D initially
#+BEGIN_SRC python :results file
  import numpy as np

  a = np.arange(1, 5)
  b = a[:, np.newaxis]

  mileposts = np.array([0, 198, 303, 736, 871, 1175, 1475, 1544, 1913, 2448])
  m_y = mileposts[:, np.newaxis]
  ans = np.abs(mileposts - m_y)

  # ravel can be used for flattening0 view
  a = np.random.randint(0, 5, (2, 2, 2), dtype=int)
  flat = a.ravel()
  # lly .flatten() for flattening0 copy

  # note -1 means inferred from number of elements present calculate 2*2*x = len(flat)
  a2 = flat.reshape(2, 2, -1)
  np.array_equal(a, a2)
#+END_SRC
#+ATTR_ORG: :width 800px

After this skipped to section 1.4 as recommended by authors

* Matplotlib
** ipython --pylab

In [4]: import numpy as np

In [5]: import matplotlib.pyplot as plt

plt.figure(figsize=(8, 6), dpi=80)


In [6]: 
In [6]: Out[6]: <Figure size 640x480 with 0 Axes>

In [7]: 
In [7]: X = np.linspace(-np.pi, np.pi, 256, endpoint=True)

In [8]: X
Out[8]: 
array([-3.14159265, -3.11695271, -3.09231277, -3.06767283, -3.04303288,
       -3.01839294, -2.993753  , -2.96911306, -2.94447311, -2.91983317,
       -2.89519323, -2.87055329, -2.84591335, -2.8212734 , -2.79663346,
       -2.77199352, -2.74735358, -2.72271363, -2.69807369, -2.67343375,
       -2.64879381, -2.62415386, -2.59951392, -2.57487398, -2.55023404,
       -2.52559409, -2.50095415, -2.47631421, -2.45167427, -2.42703432,
       -2.40239438, -2.37775444, -2.3531145 , -2.32847456, -2.30383461,
       -2.27919467, -2.25455473, -2.22991479, -2.20527484, -2.1806349 ,
       -2.15599496, -2.13135502, -2.10671507, -2.08207513, -2.05743519,
       -2.03279525, -2.0081553 , -1.98351536, -1.95887542, -1.93423548,
       -1.90959553, -1.88495559, -1.86031565, -1.83567571, -1.81103577,
       -1.78639582, -1.76175588, -1.73711594, -1.712476  , -1.68783605,
       -1.66319611, -1.63855617, -1.61391623, -1.58927628, -1.56463634,
       -1.5399964 , -1.51535646, -1.49071651, -1.46607657, -1.44143663,
       -1.41679669, -1.39215674, -1.3675168 , -1.34287686, -1.31823692,
       -1.29359698, -1.26895703, -1.24431709, -1.21967715, -1.19503721,
       -1.17039726, -1.14575732, -1.12111738, -1.09647744, -1.07183749,
       -1.04719755, -1.02255761, -0.99791767, -0.97327772, -0.94863778,
       -0.92399784, -0.8993579 , -0.87471795, -0.85007801, -0.82543807,
       -0.80079813, -0.77615819, -0.75151824, -0.7268783 , -0.70223836,
       -0.67759842, -0.65295847, -0.62831853, -0.60367859, -0.57903865,
       -0.5543987 , -0.52975876, -0.50511882, -0.48047888, -0.45583893,
       -0.43119899, -0.40655905, -0.38191911, -0.35727916, -0.33263922,
       -0.30799928, -0.28335934, -0.2587194 , -0.23407945, -0.20943951,
       -0.18479957, -0.16015963, -0.13551968, -0.11087974, -0.0862398 ,
       -0.06159986, -0.03695991, -0.01231997,  0.01231997,  0.03695991,
        0.06159986,  0.0862398 ,  0.11087974,  0.13551968,  0.16015963,
        0.18479957,  0.20943951,  0.23407945,  0.2587194 ,  0.28335934,
        0.30799928,  0.33263922,  0.35727916,  0.38191911,  0.40655905,
        0.43119899,  0.45583893,  0.48047888,  0.50511882,  0.52975876,
        0.5543987 ,  0.57903865,  0.60367859,  0.62831853,  0.65295847,
        0.67759842,  0.70223836,  0.7268783 ,  0.75151824,  0.77615819,
        0.80079813,  0.82543807,  0.85007801,  0.87471795,  0.8993579 ,
        0.92399784,  0.94863778,  0.97327772,  0.99791767,  1.02255761,
        1.04719755,  1.07183749,  1.09647744,  1.12111738,  1.14575732,
        1.17039726,  1.19503721,  1.21967715,  1.24431709,  1.26895703,
        1.29359698,  1.31823692,  1.34287686,  1.3675168 ,  1.39215674,
        1.41679669,  1.44143663,  1.46607657,  1.49071651,  1.51535646,
        1.5399964 ,  1.56463634,  1.58927628,  1.61391623,  1.63855617,
        1.66319611,  1.68783605,  1.712476  ,  1.73711594,  1.76175588,
        1.78639582,  1.81103577,  1.83567571,  1.86031565,  1.88495559,
        1.90959553,  1.93423548,  1.95887542,  1.98351536,  2.0081553 ,
        2.03279525,  2.05743519,  2.08207513,  2.10671507,  2.13135502,
        2.15599496,  2.1806349 ,  2.20527484,  2.22991479,  2.25455473,
        2.27919467,  2.30383461,  2.32847456,  2.3531145 ,  2.37775444,
        2.40239438,  2.42703432,  2.45167427,  2.47631421,  2.50095415,
        2.52559409,  2.55023404,  2.57487398,  2.59951392,  2.62415386,
        2.64879381,  2.67343375,  2.69807369,  2.72271363,  2.74735358,
        2.77199352,  2.79663346,  2.8212734 ,  2.84591335,  2.87055329,
        2.89519323,  2.91983317,  2.94447311,  2.96911306,  2.993753  ,
        3.01839294,  3.04303288,  3.06767283,  3.09231277,  3.11695271,
        3.14159265])

In [9]: S, C = sin(X), cos(X)

In [10]: plt.plot(X, S, X, C)
Out[10]: 
[<matplotlib.lines.Line2D at 0x121dcda90>,
 <matplotlib.lines.Line2D at 0x121dcdc88>]

In [11]: plt.label?
Object `plt.label` not found.

In [12]: plt.label*?


In [13]: plt.labels?
Object `plt.labels` not found.

In [14]: plt.leg*?
plt.legend

In [15]: plt.legend(('sin', 'cos))
  File "<ipython-input-15-d5f180045479>", line 1
    plt.legend(('sin', 'cos))
                             ^
SyntaxError: EOL while scanning string literal


In [16]: plt.legend(('sin', 'cos'))
Out[16]: <matplotlib.legend.Legend at 0x121e21278>

In [17]: plt.ylim(-1.0, +1.0)
Out[17]: (-1.0, 1.0)

In [18]: plt.xlim(-4.0, 4.0)
Out[18]: (-4.0, 4.0)

In [19]: plt.xlim(-np.pi, np.pi)
Out[19]: (-3.141592653589793, 3.141592653589793)

In [20]: #plt.yticks(np.linspace(-1, 1, 5, endpoint=True))

In [21]: np.linspace(-1, 1, 5, endpoint=True)
Out[21]: array([-1. , -0.5,  0. ,  0.5,  1. ])

In [22]: plt.yticks(np.linspace(-1, 1, 5, endpoint=True))
Out[22]: 
([<matplotlib.axis.YTick at 0x121db4cf8>,
  <matplotlib.axis.YTick at 0x121db4630>,
  <matplotlib.axis.YTick at 0x121df2b38>,
  <matplotlib.axis.YTick at 0x121dfdf28>,
  <matplotlib.axis.YTick at 0x121e10278>],
 <a list of 5 Text yticklabel objects>)

In [23]: #plt.plot(X, np.zeros())

In [24]: np.zeros(5)
Out[24]: array([0., 0., 0., 0., 0.])

In [25]: plt.plot(X, np.zeros())
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-25-7175f9d13573> in <module>
----> 1 plt.plot(X, np.zeros())

TypeError: zeros() missing required argument 'shape' (pos 1)

In [26]: plt.plot(X, np.zeros(2))
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-26-c4c80a126e15> in <module>
----> 1 plt.plot(X, np.zeros(2))

~/ml/flipshope/mlm2/lib/python3.7/site-packages/matplotlib/pyplot.py in plot(scalex, scaley, data, *args, **kwargs)
   2811     return gca().plot(
   2812         *args, scalex=scalex, scaley=scaley, **({"data": data} if data
-> 2813         is not None else {}), **kwargs)
   2814 
   2815 

~/ml/flipshope/mlm2/lib/python3.7/site-packages/matplotlib/__init__.py in inner(ax, data, *args, **kwargs)
   1808                         "the Matplotlib list!)" % (label_namer, func.__name__),
   1809                         RuntimeWarning, stacklevel=2)
-> 1810             return func(ax, *args, **kwargs)
   1811 
   1812         inner.__doc__ = _add_data_doc(inner.__doc__,

~/ml/flipshope/mlm2/lib/python3.7/site-packages/matplotlib/axes/_axes.py in plot(self, scalex, scaley, *args, **kwargs)
   1609         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D._alias_map)
   1610 
-> 1611         for line in self._get_lines(*args, **kwargs):
   1612             self.add_line(line)
   1613             lines.append(line)

~/ml/flipshope/mlm2/lib/python3.7/site-packages/matplotlib/axes/_base.py in _grab_next_args(self, *args, **kwargs)
    391                 this += args[0],
    392                 args = args[1:]
--> 393             yield from self._plot_args(this, kwargs)
    394 
    395 

~/ml/flipshope/mlm2/lib/python3.7/site-packages/matplotlib/axes/_base.py in _plot_args(self, tup, kwargs)
    368             x, y = index_of(tup[-1])
    369 
--> 370         x, y = self._xy_from_xy(x, y)
    371 
    372         if self.command == 'plot':

~/ml/flipshope/mlm2/lib/python3.7/site-packages/matplotlib/axes/_base.py in _xy_from_xy(self, x, y)
    229         if x.shape[0] != y.shape[0]:
    230             raise ValueError("x and y must have same first dimension, but "
--> 231                              "have shapes {} and {}".format(x.shape, y.shape))
    232         if x.ndim > 2 or y.ndim > 2:
    233             raise ValueError("x and y can be no greater than 2-D, but have "

ValueError: x and y must have same first dimension, but have shapes (256,) and (2,)

In [27]: plt.plot(X, np.zeros(256))
Out[27]: [<matplotlib.lines.Line2D at 0x126031f28>]

In [28]: 2/3
Out[28]: 0.6666666666666666

In [29]: 2 ** (-.5)
Out[29]: 0.7071067811865476

In [30]: sin(np.pi / 2)
Out[30]: 1.0

In [31]: sin(np.pi / 4)
Out[31]: 0.7071067811865475

In [32]: sin(3* np.pi / 4)
Out[32]: 0.7071067811865476

In [33]: sin(np.pi / 3)
Out[33]: 0.8660254037844386

In [34]: 3 ** .5
Out[34]: 1.7320508075688772

In [35]: (3 ** .5) / 4
Out[35]: 0.4330127018922193

In [36]: (3 ** .5) / 2
Out[36]: 0.8660254037844386

In [37]: plt.Xmax
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-37-59b378d6a5c8> in <module>
----> 1 plt.Xmax

AttributeError: module 'matplotlib.pyplot' has no attribute 'Xmax'

In [38]: plt.xmax
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-38-9026f698e34b> in <module>
----> 1 plt.xmax

AttributeError: module 'matplotlib.pyplot' has no attribute 'xmax'

In [39]: plt.xlim(X.max() * 1.1)
Out[39]: (3.455751918948773, 3.141592653589793)

In [40]: plt.xlim(X.min() * 1.1, X.max() * 1.1)
Out[40]: (-3.455751918948773, 3.455751918948773)

In [41]: plt.xlim(X.min() + 0.5, X.max() + 0.5)
Out[41]: (-2.641592653589793, 3.641592653589793)

In [42]: plt.xlim(X.min() - 0.5, X.max() + 0.5)
Out[42]: (-3.641592653589793, 3.641592653589793)

In [43]: plt.ylim(Y.min() - 0.5, Y.max() + 0.5)
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-43-34d48cb3488c> in <module>
----> 1 plt.ylim(Y.min() - 0.5, Y.max() + 0.5)

NameError: name 'Y' is not defined

In [44]: plt.ylim(S.min() - 0.25, S.max() + 0.25)
Out[44]: (-1.2499810273487268, 1.2499810273487268)

In [45]: plt.xticks([-np.pi, -3 * np.pi / 2, -np.pi / 2, -np.pi / 4, 0, np.pi / 4 , np.pi / 2, 3 * np.pi / 2, ,  np.pi])

  File "<ipython-input-45-adc65bcd297e>", line 1
    plt.xticks([-np.pi, -3 * np.pi / 2, -np.pi / 2, -np.pi / 4, 0, np.pi / 4 , np.pi / 2, 3 * np.pi / 2, ,  np.pi])
                                                                                                         ^
SyntaxError: invalid syntax


In [46]: 
In [46]: [-np.pi, -3 * np.pi / 2, -np.pi / 2, -np.pi / 4, 0, np.pi / 4 , np.pi / 2, 3 * np.pi / 2, ,  np.pi]

  File "<ipython-input-46-74c406e61e87>", line 1
    [-np.pi, -3 * np.pi / 2, -np.pi / 2, -np.pi / 4, 0, np.pi / 4 , np.pi / 2, 3 * np.pi / 2, ,  np.pi]
                                                                                              ^
SyntaxError: invalid syntax


In [47]: 
In [47]: plt.xticks([-np.pi, -3 * np.pi / 2, -np.pi / 2, -np.pi / 4, 0, np.pi / 4 , np.pi / 2, 3 * np.pi / 2,  np.pi])

Out[47]: 
([<matplotlib.axis.XTick at 0x1173fc5c0>,
  <matplotlib.axis.XTick at 0x11e081978>,
  <matplotlib.axis.XTick at 0x11df97da0>,
  <matplotlib.axis.XTick at 0x121ddf4e0>,
  <matplotlib.axis.XTick at 0x121ddfa20>,
  <matplotlib.axis.XTick at 0x121ddfef0>,
  <matplotlib.axis.XTick at 0x121df2400>,
  <matplotlib.axis.XTick at 0x121ddfac8>,
  <matplotlib.axis.XTick at 0x121df2278>],
 <a list of 9 Text xticklabel objects>)

In [48]: 
In [48]: plt.xli?
Object `plt.xli` not found.

In [49]: plt.xli*?
plt.xlim

In [50]: plt.xlim(-np.pi * 1.1, np.pi * 1.1)
Out[50]: (-3.455751918948773, 3.455751918948773)

In [51]: plt.xticks([-np.pi, -3 * np.pi / 2, -np.pi / 2, -np.pi / 4, 0, np.pi / 4 , np.pi / 2, 3 * np.pi / 2,  np.pi], ["-pi", "-.75pi", "-.5pi", "-.25pi", "0", ".25pi", ".5pi", ".75pi", "pi"])

Out[51]: 
([<matplotlib.axis.XTick at 0x1173fc5c0>,
  <matplotlib.axis.XTick at 0x11e081978>,
  <matplotlib.axis.XTick at 0x11df97da0>,
  <matplotlib.axis.XTick at 0x121ddf4e0>,
  <matplotlib.axis.XTick at 0x121ddfa20>,
  <matplotlib.axis.XTick at 0x121ddfef0>,
  <matplotlib.axis.XTick at 0x121df2400>,
  <matplotlib.axis.XTick at 0x121ddfac8>,
  <matplotlib.axis.XTick at 0x121df2278>],
 <a list of 9 Text xticklabel objects>)

In [52]: 
In [52]: plt.xlim(-np.pi * 1.1, np.pi * 1.1)
Out[52]: (-3.455751918948773, 3.455751918948773)

In [53]: plt.xticks([-np.pi, -3 * np.pi / 2, -np.pi / 2, -np.pi / 4, 0, np.pi / 4 , np.pi / 2, 3 * np.pi / 2,  np.pi], ["-pi", "-.75pi", "-.5pi", "-.25pi", "0", ".25pi", ".5pi", ".75pi", "pi"])

Out[53]: 
([<matplotlib.axis.XTick at 0x1173fc5c0>,
  <matplotlib.axis.XTick at 0x11e081978>,
  <matplotlib.axis.XTick at 0x11df97da0>,
  <matplotlib.axis.XTick at 0x121ddf4e0>,
  <matplotlib.axis.XTick at 0x121ddfa20>,
  <matplotlib.axis.XTick at 0x121ddfef0>,
  <matplotlib.axis.XTick at 0x121df2400>,
  <matplotlib.axis.XTick at 0x121ddfac8>,
  <matplotlib.axis.XTick at 0x121df2278>],
 <a list of 9 Text xticklabel objects>)

In [54]: 
In [54]: plt.xticks([-np.pi, -3 * np.pi / 4, -np.pi / 2, -np.pi / 4, 0, np.pi / 4 , np.pi / 2, 3 * np.pi / 4,  np.pi], ["-pi", "-.75pi", "-.5pi", "-.25pi", "0", ".25pi", ".5pi", ".75pi", "pi"])

Out[54]: 
([<matplotlib.axis.XTick at 0x1173fc5c0>,
  <matplotlib.axis.XTick at 0x11e081978>,
  <matplotlib.axis.XTick at 0x11df97da0>,
  <matplotlib.axis.XTick at 0x121ddf4e0>,
  <matplotlib.axis.XTick at 0x121ddfa20>,
  <matplotlib.axis.XTick at 0x121ddfef0>,
  <matplotlib.axis.XTick at 0x121df2400>,
  <matplotlib.axis.XTick at 0x121ddfac8>,
  <matplotlib.axis.XTick at 0x121df2278>],
 <a list of 9 Text xticklabel objects>)

In [55]: 
In [55]: plt.xlim(-np.pi * 1.1, np.pi * 1.1)
Out[55]: (-3.455751918948773, 3.455751918948773)

In [56]: ax = plt.gca()

In [57]: ax
Out[57]: <matplotlib.axes._subplots.AxesSubplot at 0x11ddc05f8>

In [58]: ax.spines['right']
Out[58]: <matplotlib.spines.Spine at 0x11e05bd30>

In [59]: ax.spines['right'].set_color('none')

In [60]: ax.spines['top'].set_color('none')

In [61]: ax.spines['left'].set_position(('data', 0))

In [62]: ax.spines['bottom'].set_position(('data', 0))

In [63]: 
#+BEGIN_SRC python :results file
  import numpy as np
  import matplotlib.pyplot as plt

  plt.figure(figsize=(8, 6), dpi=80)
#+END_SRC
#+ATTR_ORG: :width 800px

** 1.4.3 stopped here
** restarted matplotlib after restart at flipshope on Feb4
Matplotlib code is in its own separate notebook
